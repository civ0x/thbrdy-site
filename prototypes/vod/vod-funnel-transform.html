<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VoD Sequential Funnel — Transformation Prototype</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #FAF6F0;
    --bg-warm: #F4EFE7;
    --bg-card: #EFEBE4;
    --border: rgba(44, 36, 22, 0.1);
    --border-mid: rgba(44, 36, 22, 0.18);
    --text: #2C2416;
    --text-mid: #4A3D30;
    --text-light: #6B5D4F;
    --text-muted: #9B8E80;
    --text-faint: #C4B8AA;
    --accent: #B8860B;
    --accent-dim: rgba(184, 134, 11, 0.08);
    --accent-glow: rgba(184, 134, 11, 0.15);
    --teal: #2A7A6A;
    --green: #4A7A4A;
    --blue: #2A5A8A;
  }

  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Cormorant Garamond', serif;
    line-height: 1.6;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 60px 24px 120px;
  }

  /* ── Context label ── */
  .prototype-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    font-weight: 500;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-faint);
    margin-bottom: 60px;
    text-align: center;
  }

  /* ── Header ── */
  .header {
    text-align: center;
    margin-bottom: 2.5rem;
  }
  .eyebrow {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 500;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 0.5rem;
  }
  .title {
    font-family: 'Cormorant Garamond', serif;
    font-size: 1.5rem;
    font-weight: 400;
    color: var(--text);
  }

  /* ── Main container ── */
  .funnel-root {
    max-width: 680px;
    width: 100%;
  }

  /* ── Toggle control ── */
  .toggle-wrap {
    display: flex;
    justify-content: center;
    margin-bottom: 2rem;
    gap: 12px;
    align-items: center;
  }
  .toggle-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    transition: color 0.4s ease;
    cursor: pointer;
    user-select: none;
  }
  .toggle-label--left { color: var(--text-muted); }
  .toggle-label--right { color: var(--text-muted); }
  .toggle-label--active { color: var(--accent); }

  .toggle-track {
    width: 52px;
    height: 28px;
    border-radius: 14px;
    background: var(--bg-card);
    border: 1px solid var(--border-mid);
    position: relative;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  .toggle-track:hover {
    background: var(--bg-warm);
  }
  .toggle-thumb {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: var(--accent);
    position: absolute;
    top: 2px;
    left: 2px;
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    box-shadow: 0 1px 4px rgba(44, 36, 22, 0.15);
  }
  .toggle-thumb--right {
    transform: translateX(24px);
  }

  /* ── Diagram area ── */
  .diagram-area {
    position: relative;
    width: 100%;
    aspect-ratio: 4 / 3;
    margin-bottom: 1.5rem;
  }

  /* ── SVG edges ── */
  .diagram-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
  }
  .edge {
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  /* ── Nodes ── */
  .node {
    position: absolute;
    padding: 12px 18px;
    background: var(--bg);
    border: 1.5px solid var(--border-mid);
    border-radius: 8px;
    z-index: 2;
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    text-align: center;
    box-shadow: 0 1px 6px rgba(44, 36, 22, 0.04);
    cursor: default;
  }
  .node:hover {
    border-color: var(--accent);
    box-shadow: 0 2px 12px rgba(184, 134, 11, 0.08);
  }
  .node-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.8125rem;
    font-weight: 600;
    color: var(--text);
    white-space: nowrap;
  }

  /* ── Edge count ── */
  .edge-count {
    text-align: center;
    margin-bottom: 1.5rem;
  }
  .edge-count-inner {
    display: inline-flex;
    align-items: baseline;
    gap: 8px;
  }
  .edge-count-number {
    font-family: 'DM Sans', sans-serif;
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--accent);
    line-height: 1;
    transition: opacity 0.3s ease;
  }
  .edge-count-label {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-muted);
  }
  .edge-count-sub {
    font-family: 'Cormorant Garamond', serif;
    font-size: 0.9rem;
    color: var(--text-light);
    font-style: italic;
    margin-top: 4px;
  }

  /* ── Gate markers (sequential mode) ── */
  .gate-marker {
    position: absolute;
    z-index: 3;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    transition: opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    pointer-events: none;
  }
  .gate-diamond {
    width: 6px;
    height: 6px;
    background: var(--text-faint);
    transform: rotate(45deg);
  }
  .gate-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.5rem;
    font-weight: 500;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-faint);
    white-space: nowrap;
  }

  /* ── Lost edge callouts ── */
  .lost-edges {
    margin-bottom: 2rem;
    transition: opacity 0.6s ease 0.3s, max-height 0.6s ease;
    overflow: hidden;
  }
  .lost-edges--hidden {
    opacity: 0;
    max-height: 0;
    margin-bottom: 0;
  }
  .lost-edges--visible {
    opacity: 1;
    max-height: 200px;
  }
  .lost-edges-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.6rem;
    font-weight: 500;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--red, #A63D2F);
    margin-bottom: 8px;
    text-align: center;
  }
  .lost-edge-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: center;
  }
  .lost-edge-chip {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.6875rem;
    font-weight: 500;
    color: var(--text-muted);
    background: var(--bg-warm);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 4px 10px;
    text-decoration: line-through;
    text-decoration-color: rgba(166, 61, 47, 0.4);
  }

  /* ── Callout ── */
  .callout {
    padding: 16px 20px;
    background: var(--accent-dim);
    border-left: 3px solid var(--accent);
    border-radius: 0 8px 8px 0;
  }
  .callout-text {
    font-family: 'Cormorant Garamond', serif;
    font-size: 0.95rem;
    color: var(--text-mid);
    line-height: 1.6;
  }

  /* ── Hover detail ── */
  .hover-detail {
    margin-top: 1.5rem;
    padding: 12px 16px;
    border-radius: 6px;
    min-height: 48px;
    display: flex;
    align-items: center;
    transition: all 0.3s ease;
  }
  .hover-detail--active {
    background: var(--bg-warm);
    border-left: 3px solid var(--accent);
  }
  .hover-detail--empty {
    background: transparent;
    border-left: 3px solid var(--border);
  }
  .hover-detail-text {
    font-family: 'Cormorant Garamond', serif;
    font-size: 0.875rem;
    color: var(--text-mid);
    line-height: 1.5;
  }
  .hover-detail-placeholder {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.75rem;
    color: var(--text-faint);
  }

  /* ── Node selected state ── */
  .node--selected {
    border-color: var(--accent);
    box-shadow: 0 2px 16px rgba(184, 134, 11, 0.12);
    background: var(--bg-warm);
  }
  .node { cursor: pointer; }

  /* ── Node explanation panel ── */
  .node-explain {
    margin-top: 1rem;
    padding: 14px 18px;
    border-radius: 8px;
    background: var(--bg-warm);
    border-left: 3px solid var(--accent);
    transition: opacity 0.3s ease, max-height 0.4s ease;
    overflow: hidden;
  }
  .node-explain--hidden {
    opacity: 0;
    max-height: 0;
    padding: 0 18px;
    margin-top: 0;
    border-left-color: transparent;
  }
  .node-explain--visible {
    opacity: 1;
    max-height: 300px;
  }
  .node-explain-header {
    display: flex;
    align-items: baseline;
    gap: 8px;
    margin-bottom: 6px;
  }
  .node-explain-name {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.8125rem;
    font-weight: 700;
    color: var(--text);
  }
  .node-explain-mode {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.55rem;
    font-weight: 500;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--accent);
    background: var(--accent-dim);
    padding: 2px 6px;
    border-radius: 3px;
  }
  .node-explain-text {
    font-family: 'Cormorant Garamond', serif;
    font-size: 0.9rem;
    color: var(--text-mid);
    line-height: 1.6;
  }

  /* ── Responsive ── */
  @media (max-width: 640px) {
    .node-label { font-size: 0.75rem; }
    .node { padding: 8px 12px; }
    .edge-count-number { font-size: 2rem; }
  }
  @media (max-width: 420px) {
    .diagram-area { aspect-ratio: 1; }
    .node-label { font-size: 0.6875rem; }
    .node { padding: 6px 10px; }
  }

  /* ── Reduced motion ── */
  @media (prefers-reduced-motion: reduce) {
    .node, .edge, .toggle-thumb, .gate-marker, .lost-edges {
      transition-duration: 0.01s !important;
    }
  }
</style>
</head>
<body>

<div class="prototype-label">Prototype · VoD Sequential Funnel · Transformation Animation</div>

<div class="funnel-root">
  <div class="header">
    <p class="eyebrow">Information Loss</p>
    <h3 class="title">What sequential evaluation can't see.</h3>
  </div>

  <div class="toggle-wrap">
    <span class="toggle-label toggle-label--left toggle-label--active" id="label-seq">Sequential</span>
    <div class="toggle-track" id="toggle" role="switch" aria-checked="false" tabindex="0">
      <div class="toggle-thumb" id="thumb"></div>
    </div>
    <span class="toggle-label toggle-label--right" id="label-actual">Actual</span>
  </div>

  <div class="diagram-area" id="diagram">
    <svg class="diagram-svg" id="edgeSvg" viewBox="0 0 680 510"></svg>
    <!-- Nodes injected by JS -->
    <!-- Gate markers injected by JS -->
  </div>

  <div class="edge-count">
    <div class="edge-count-inner">
      <span class="edge-count-number" id="countNum">3</span>
      <span class="edge-count-label" id="countLabel">visible connections</span>
    </div>
    <div class="edge-count-sub" id="countSub">3 dependencies hidden by sequential ordering</div>
  </div>

  <div class="lost-edges lost-edges--visible" id="lostEdges">
    <div class="lost-edges-title">Lost in sequential evaluation</div>
    <div class="lost-edge-list" id="lostEdgeList"></div>
  </div>

  <div class="hover-detail hover-detail--empty" id="hoverDetail">
    <span class="hover-detail-placeholder" id="hoverText">Toggle to see how sequential ordering hides dependencies</span>
  </div>

  <div class="node-explain node-explain--hidden" id="nodeExplain">
    <div class="node-explain-header">
      <span class="node-explain-name" id="nodeExplainName"></span>
      <span class="node-explain-mode" id="nodeExplainMode"></span>
    </div>
    <p class="node-explain-text" id="nodeExplainText"></p>
  </div>

  <div class="callout" style="margin-top: 1.5rem;">
    <p class="callout-text">
      Sequential evaluation sees <strong id="calloutSeq">3</strong> forward connections.
      The actual structure has <strong>6</strong> bidirectional dependencies.
      <span id="calloutDelta"> — half the information is invisible.</span>
    </p>
  </div>
</div>

<script>
(function() {
  // ── Data ──
  const nodes = [
    {
      id: 'research',
      label: 'Research Review',
      short: 'Research',
      seq: 'Evaluates technical novelty and scientific rigor in isolation. Passes a confidence score forward — but has no visibility into what the market needs or what engineering can actually build.',
      actual: 'Technical capability that simultaneously constrains what markets become addressable, what architectures are feasible, and what investment risk the executive is underwriting. Every other evaluation depends on this one.',
    },
    {
      id: 'market',
      label: 'Market Assessment',
      short: 'Market',
      seq: 'Receives a "research-approved" candidate and assesses market size and timing. Cannot push back on the research framing — only decides whether the opportunity is big enough to continue.',
      actual: 'Market reality shapes what "good enough" means for research, sets performance targets for engineering, and determines whether the business case justifies executive investment. It constrains three other evaluations, not just the one downstream.',
    },
    {
      id: 'engineering',
      label: 'Engineering Feasibility',
      short: 'Engineering',
      seq: 'Estimates build cost and timeline for whatever research and market have already approved. Can flag infeasibility but cannot reshape the research approach or reframe the market target.',
      actual: 'Build complexity feeds back into research approach (some architectures make certain research directions impractical) and directly determines the cost structure executives evaluate. Engineering is a constraint on research, not just a recipient of it.',
    },
    {
      id: 'executive',
      label: 'Executive Approval',
      short: 'Executive',
      seq: 'Final go/no-go based on the package that survived three prior gates. Sees only what sequential filtering preserved — the original research risk, market uncertainty, and engineering trade-offs have been compressed into a summary.',
      actual: 'Investment appetite is shaped directly by research risk, market size, and build complexity — three independent inputs, not a single filtered package. The executive evaluation also constrains what research gets funded next, closing the loop.',
    },
  ];

  const edges = [
    { from: 'research',    to: 'market',      label: 'What counts as "good enough" depends on what the market requires', sequential: true },
    { from: 'market',      to: 'engineering',  label: 'Target market determines performance requirements', sequential: true },
    { from: 'engineering', to: 'executive',    label: 'Build complexity determines timeline and cost', sequential: true },
    { from: 'research',    to: 'engineering',  label: 'Technical approach constrains build cost', sequential: false },
    { from: 'research',    to: 'executive',    label: 'Research risk shapes investment appetite', sequential: false },
    { from: 'market',      to: 'executive',    label: 'Market size justifies resource allocation', sequential: false },
  ];

  const edgeColors = {
    'research-market': 'var(--teal)',
    'research-engineering': 'var(--green)',
    'research-executive': 'var(--blue)',
    'market-engineering': 'var(--teal)',
    'market-executive': 'var(--green)',
    'engineering-executive': 'var(--blue)',
  };

  // ── Positions ──
  // Sequential: vertical stack, centered
  const seqPositions = {
    research:    { x: 50, y: 8 },
    market:      { x: 50, y: 33 },
    engineering: { x: 50, y: 58 },
    executive:   { x: 50, y: 83 },
  };

  // Actual: diamond layout
  const actualPositions = {
    research:    { x: 50, y: 8 },
    market:      { x: 12, y: 50 },
    engineering: { x: 88, y: 50 },
    executive:   { x: 50, y: 88 },
  };

  // Gate positions (between sequential nodes)
  const gatePositions = [
    { x: 50, y: 20.5 },
    { x: 50, y: 45.5 },
    { x: 50, y: 70.5 },
  ];

  let isActual = false;
  let hoveredEdgeIdx = null;
  let selectedNodeId = null;

  const diagram = document.getElementById('diagram');
  const edgeSvg = document.getElementById('edgeSvg');
  const toggle = document.getElementById('toggle');
  const thumb = document.getElementById('thumb');
  const labelSeq = document.getElementById('label-seq');
  const labelActual = document.getElementById('label-actual');
  const countNum = document.getElementById('countNum');
  const countLabel = document.getElementById('countLabel');
  const countSub = document.getElementById('countSub');
  const lostEdges = document.getElementById('lostEdges');
  const lostEdgeList = document.getElementById('lostEdgeList');
  const hoverDetail = document.getElementById('hoverDetail');
  const hoverText = document.getElementById('hoverText');
  const calloutSeq = document.getElementById('calloutSeq');
  const calloutDelta = document.getElementById('calloutDelta');

  const nodeExplain = document.getElementById('nodeExplain');
  const nodeExplainName = document.getElementById('nodeExplainName');
  const nodeExplainMode = document.getElementById('nodeExplainMode');
  const nodeExplainText = document.getElementById('nodeExplainText');

  // ── Build DOM ──

  // Create node elements
  const nodeEls = {};
  nodes.forEach(n => {
    const el = document.createElement('div');
    el.className = 'node';
    el.innerHTML = '<span class="node-label">' + n.label + '</span>';
    el.dataset.id = n.id;

    el.addEventListener('click', function(evt) {
      evt.stopPropagation();
      if (selectedNodeId === n.id) {
        selectedNodeId = null;
      } else {
        selectedNodeId = n.id;
      }
      updateNodeSelection();
    });

    diagram.appendChild(el);
    nodeEls[n.id] = el;
  });

  // Click outside diagram clears node selection
  document.addEventListener('click', function() {
    if (selectedNodeId !== null) {
      selectedNodeId = null;
      updateNodeSelection();
    }
  });
  // Prevent toggle clicks from clearing selection
  document.querySelector('.toggle-wrap').addEventListener('click', function(evt) {
    evt.stopPropagation();
  });

  // Create gate markers
  const gateEls = [];
  gatePositions.forEach((pos, i) => {
    const el = document.createElement('div');
    el.className = 'gate-marker';
    el.innerHTML = '<div class="gate-diamond"></div><span class="gate-label">Gate ' + (i + 1) + '</span>';
    diagram.appendChild(el);
    gateEls.push(el);
  });

  // Create SVG edge lines with fat invisible hit targets
  const edgeEls = [];
  const hitTargets = [];
  edges.forEach((e, i) => {
    // Fat invisible hit target (wide stroke for easy hovering)
    const hit = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    hit.setAttribute('stroke', 'transparent');
    hit.setAttribute('stroke-width', '18');
    hit.style.pointerEvents = 'stroke';
    hit.style.cursor = 'pointer';

    hit.addEventListener('mouseenter', function() {
      hoveredEdgeIdx = i;
      updateHover();
      updateEdgeHighlight();
    });
    hit.addEventListener('mouseleave', function() {
      hoveredEdgeIdx = null;
      updateHover();
      updateEdgeHighlight();
    });

    // Visible line (no pointer events — the hit target handles them)
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.classList.add('edge');
    const key = e.from + '-' + e.to;
    line.setAttribute('stroke', edgeColors[key] || 'var(--border-mid)');
    line.setAttribute('stroke-width', '1.5');
    line.style.pointerEvents = 'none';

    edgeSvg.appendChild(line);
    edgeSvg.appendChild(hit);
    edgeEls.push(line);
    hitTargets.push(hit);
  });

  // Build lost-edge chips
  const nonSeqEdges = edges.filter(e => !e.sequential);
  nonSeqEdges.forEach(e => {
    const fromNode = nodes.find(n => n.id === e.from);
    const toNode = nodes.find(n => n.id === e.to);
    const chip = document.createElement('span');
    chip.className = 'lost-edge-chip';
    chip.textContent = fromNode.short + ' ↔ ' + toNode.short;
    lostEdgeList.appendChild(chip);
  });

  // ── Position helpers ──
  function getPositions() {
    return isActual ? actualPositions : seqPositions;
  }

  function pctToSvg(pctX, pctY) {
    return { x: pctX / 100 * 680, y: pctY / 100 * 510 };
  }

  // ── Update functions ──
  function updateNodes() {
    const pos = getPositions();
    nodes.forEach(n => {
      const el = nodeEls[n.id];
      const p = pos[n.id];
      el.style.left = p.x + '%';
      el.style.top = p.y + '%';
      el.style.transform = 'translate(-50%, -50%)';
    });
  }

  function updateEdges() {
    const pos = getPositions();
    edges.forEach((e, i) => {
      const from = pctToSvg(pos[e.from].x, pos[e.from].y);
      const to = pctToSvg(pos[e.to].x, pos[e.to].y);
      const line = edgeEls[i];
      const hit = hitTargets[i];

      if (isActual) {
        // All edges visible
        line.setAttribute('x1', from.x);
        line.setAttribute('y1', from.y);
        line.setAttribute('x2', to.x);
        line.setAttribute('y2', to.y);
        line.setAttribute('opacity', '0.5');
        line.setAttribute('stroke-dasharray', 'none');
        // Sync hit target
        hit.setAttribute('x1', from.x);
        hit.setAttribute('y1', from.y);
        hit.setAttribute('x2', to.x);
        hit.setAttribute('y2', to.y);
        hit.style.pointerEvents = 'stroke';
      } else {
        if (e.sequential) {
          line.setAttribute('x1', from.x);
          line.setAttribute('y1', from.y);
          line.setAttribute('x2', to.x);
          line.setAttribute('y2', to.y);
          line.setAttribute('opacity', '0.5');
          line.setAttribute('stroke-dasharray', 'none');
          hit.setAttribute('x1', from.x);
          hit.setAttribute('y1', from.y);
          hit.setAttribute('x2', to.x);
          hit.setAttribute('y2', to.y);
          hit.style.pointerEvents = 'stroke';
        } else {
          // Hidden edges: collapsed to zero-length at midpoint
          const mx = (from.x + to.x) / 2;
          const my = (from.y + to.y) / 2;
          line.setAttribute('x1', mx);
          line.setAttribute('y1', my);
          line.setAttribute('x2', mx);
          line.setAttribute('y2', my);
          line.setAttribute('opacity', '0');
          hit.setAttribute('x1', mx);
          hit.setAttribute('y1', my);
          hit.setAttribute('x2', mx);
          hit.setAttribute('y2', my);
          hit.style.pointerEvents = 'none';
        }
      }
    });
  }

  function updateEdgeHighlight() {
    edges.forEach((e, i) => {
      const line = edgeEls[i];
      if (hoveredEdgeIdx === i) {
        line.setAttribute('stroke-width', '3');
        line.setAttribute('opacity', '1');
      } else {
        line.setAttribute('stroke-width', '1.5');
        if (isActual || e.sequential) {
          line.setAttribute('opacity', hoveredEdgeIdx !== null ? '0.25' : '0.5');
        }
      }
    });
  }

  function updateGates() {
    gateEls.forEach((el, i) => {
      const p = gatePositions[i];
      el.style.left = p.x + '%';
      el.style.top = p.y + '%';
      el.style.transform = 'translate(-50%, -50%)';
      el.style.opacity = isActual ? '0' : '1';
    });
  }

  function updateCounts() {
    const visible = isActual ? 6 : 3;
    countNum.textContent = visible;
    countLabel.textContent = isActual ? 'bidirectional dependencies' : 'visible connections';
    countSub.textContent = isActual
      ? 'All dependencies visible — the full constraint structure'
      : '3 dependencies hidden by sequential ordering';
    calloutSeq.textContent = isActual ? '6' : '3';
    calloutDelta.textContent = isActual
      ? ' — nothing is hidden.'
      : ' — half the information is invisible.';
  }

  function updateLostEdges() {
    if (isActual) {
      lostEdges.className = 'lost-edges lost-edges--hidden';
    } else {
      lostEdges.className = 'lost-edges lost-edges--visible';
    }
  }

  function updateToggle() {
    if (isActual) {
      thumb.classList.add('toggle-thumb--right');
      labelSeq.classList.remove('toggle-label--active');
      labelActual.classList.add('toggle-label--active');
    } else {
      thumb.classList.remove('toggle-thumb--right');
      labelSeq.classList.add('toggle-label--active');
      labelActual.classList.remove('toggle-label--active');
    }
  }

  function updateHover() {
    if (hoveredEdgeIdx !== null) {
      const e = edges[hoveredEdgeIdx];
      hoverDetail.className = 'hover-detail hover-detail--active';
      hoverText.className = 'hover-detail-text';
      hoverText.textContent = e.label;
    } else {
      hoverDetail.className = 'hover-detail hover-detail--empty';
      hoverText.className = 'hover-detail-placeholder';
      hoverText.textContent = isActual
        ? 'Hover an edge to see the bidirectional constraint'
        : 'Toggle to see how sequential ordering hides dependencies';
    }
  }

  function updateNodeSelection() {
    // Toggle selected class on nodes
    nodes.forEach(n => {
      const el = nodeEls[n.id];
      if (n.id === selectedNodeId) {
        el.classList.add('node--selected');
      } else {
        el.classList.remove('node--selected');
      }
    });

    // Show/hide explanation panel
    if (selectedNodeId) {
      const n = nodes.find(nd => nd.id === selectedNodeId);
      nodeExplainName.textContent = n.label;
      nodeExplainMode.textContent = isActual ? 'Actual view' : 'Sequential view';
      nodeExplainText.textContent = isActual ? n.actual : n.seq;
      nodeExplain.className = 'node-explain node-explain--visible';

      // Also highlight connected edges
      edges.forEach((e, i) => {
        const line = edgeEls[i];
        const connected = (e.from === selectedNodeId || e.to === selectedNodeId);
        if (isActual || e.sequential) {
          line.setAttribute('opacity', connected ? '0.8' : '0.15');
          line.setAttribute('stroke-width', connected ? '2.5' : '1');
        }
      });
    } else {
      nodeExplain.className = 'node-explain node-explain--hidden';
      // Reset edge styling
      updateEdgeHighlight();
    }
  }

  function update() {
    updateNodes();
    updateEdges();
    updateGates();
    updateCounts();
    updateLostEdges();
    updateToggle();
    updateHover();
    updateNodeSelection();
  }

  // ── Events ──
  function doToggle() {
    isActual = !isActual;
    hoveredEdgeIdx = null;
    // Keep node selected across toggle so the explanation updates to the new framing
    update();
  }

  toggle.addEventListener('click', doToggle);
  toggle.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); doToggle(); }
  });
  labelSeq.addEventListener('click', function() { if (isActual) doToggle(); });
  labelActual.addEventListener('click', function() { if (!isActual) doToggle(); });

  // ── Init ──
  update();
})();
</script>

</body>
</html>
